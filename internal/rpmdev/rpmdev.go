package rpmdev

import (
	"encoding/json"
	"fmt"
	"github.com/Masterminds/semver"
	"github.com/dyammarcano/rpmbuild-cli/internal/rpmdev/normalizer"
	"github.com/dyammarcano/rpmbuild-cli/internal/rpmdev/utils"
	"github.com/mattn/go-zglob"
	"github.com/pkg/errors"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

// Package contains the build information
type (
	Package struct {
		Name          string            `json:"name"`
		Version       string            `json:"version,omitempty"`
		Arch          string            `json:"arch,omitempty"`
		Release       string            `json:"release,omitempty"`
		Group         string            `json:"group,omitempty"`
		License       string            `json:"license,omitempty"`
		URL           string            `json:"url,omitempty"`
		Summary       string            `json:"summary,omitempty"`
		Description   string            `json:"description,omitempty"`
		ChangelogFile string            `json:"changelog-file,omitempty"`
		ChangelogCmd  string            `json:"changelog-cmd,omitempty"`
		Files         []fileInstruction `json:"files,omitempty"`
		PreInst       string            `json:"preinst,omitempty"`
		PostInst      string            `json:"postinst,omitempty"`
		PreRm         string            `json:"prerm,omitempty"`
		PostRm        string            `json:"postrm,omitempty"`
		Verify        string            `json:"verify,omitempty"`
		BuildRequires []string          `json:"build-requires,omitempty"`
		Requires      []string          `json:"requires,omitempty"`
		Provides      []string          `json:"provides,omitempty"`
		Conflicts     []string          `json:"conflicts,omitempty"`
		Envs          map[string]string `json:"envs,omitempty"`
		AutoReqProv   string            `json:"auto-req-prov,omitempty"`
	}

	FileInst struct {
		From string
		To   string
		Base string
	}

	fileInstruction struct {
		From string `json:"from,omitempty"`
		To   string `json:"to,omitempty"`
		Base string `json:"base,omitempty"`
		Type string `json:"type,omitempty"`
	}

	Entry struct {
		Key, Value string
	}
)

func (p *Package) Load(file string) error {
	if _, err := os.Stat(file); os.IsNotExist(err) {
		return errors.Errorf("json file '%s' does not exist: %s", file, err.Error())
	}

	byt, err := os.ReadFile(file)
	if err != nil {
		return errors.Errorf("error occured while reading file '%s': %s", file, err.Error())
	}

	if err := json.Unmarshal(byt, p); err != nil {
		return errors.Errorf("Invalid json file '%s': %s", file, err.Error())
	}
	return nil
}

func (p *Package) Normalize(arch string, version string) error {
	newNormalizer := normalizer.NewNormalizer(p)
	newNormalizer.SetTokens(arch, version)
	newNormalizer.NormalizeProperties()

	if p.Release == "" {
		p.Release = "1"
	}

	if p.Version == "" {
		p.Version = version
	}

	if p.Arch == "" {
		p.Arch = arch
	}

	// The rest of your function goes here...
	// All other code parts can also be split into separate methods of Normalizer for clarity

	return nil
}

func (p *Package) InitializeBuildArea(buildAreaPath string) error {
	paths := make([]string, 0)
	paths = append(paths, filepath.Join(buildAreaPath, "BUILD"))
	paths = append(paths, filepath.Join(buildAreaPath, "RPMS"))
	paths = append(paths, filepath.Join(buildAreaPath, "SOURCES"))
	paths = append(paths, filepath.Join(buildAreaPath, "SPECS"))
	paths = append(paths, filepath.Join(buildAreaPath, "SRPMS"))
	paths = append(paths, filepath.Join(buildAreaPath, "RPMS", "i386"))
	paths = append(paths, filepath.Join(buildAreaPath, "RPMS", "amd64"))

	for _, p := range paths {
		if err := os.MkdirAll(p, 0755); err != nil {
			return errors.WithStack(err)
		}
	}
	return nil
}

func (p *Package) WriteSpecFile(sourceDir string, buildAreaPath string) error {
	spec, err := p.GenerateSpecFile(sourceDir)
	if err != nil {
		return errors.WithStack(err)
	}
	path := filepath.Join(buildAreaPath, "SPECS", p.Name+".spec")
	return os.WriteFile(path, []byte(spec), 0644)
}

func (p *Package) RunBuild(buildAreaPath string, output string) error {
	path := filepath.Join(buildAreaPath, "SPECS", p.Name+".spec")
	def := "_topdir " + buildAreaPath
	arch := p.Arch
	if arch == "386" {
		arch = "i386"
	}
	if arch == "amd64" {
		arch = "x86_64"
	}
	args := []string{"--target", arch, "-bb", path, "--define", def}
	log.Printf("%s %s\n", "rpmbuild", args)
	oCmd := exec.Command("rpmbuild", args...)
	oCmd.Stdout = os.Stdout
	oCmd.Stderr = os.Stderr
	if err := oCmd.Run(); err != nil {
		return errors.WithStack(err)
	}
	// if version contains a prerelease,
	// destination file generated by rpmbuild is like
	// [name]-[version]-[prerelease].[release].[arch].rpm
	// otherwise
	// [name]-[version]-[release].[arch].rpm
	pkg := fmt.Sprintf("%s/RPMS/%s/%s-%s-%s.%s.rpm", buildAreaPath, arch, p.Name, p.Version, p.Release, arch)
	v, err := semver.NewVersion(p.Version)
	if err != nil {
		return errors.WithStack(err)
	}
	if v.Prerelease() != "" {
		pkg = fmt.Sprintf("%s/RPMS/%s/%s-%s.%s.%s.rpm", buildAreaPath, arch, p.Name, p.Version, p.Release, arch)
	}
	return utils.Cp(output, pkg)
}

func generateVersion(p *Package) (string, string, error) {
	v, err := semver.NewVersion(p.Version)
	if err != nil {
		return "", "", errors.WithStack(err)
	}
	okVersion := fmt.Sprintf("%d.%d.%d", v.Major(), v.Minor(), v.Patch())
	preRelease := p.Release
	if v.Prerelease() != "" {
		preRelease = fmt.Sprintf("%s.%s", v.Prerelease(), preRelease)
	}
	return okVersion, preRelease, nil
}

func (p *Package) preCheckString(contentBuilder strings.Builder, key string, value string) {
	if value != "" {
		contentBuilder.WriteString(fmt.Sprintf("%s: %s\n", key, value))
	}
}

func (p *Package) generateSpecContent(okVersion string, preRelease string, sourceDir string) (string, error) {
	var contentBuilder strings.Builder

	p.preCheckString(contentBuilder, "Name: %s\n", p.Name)
	p.preCheckString(contentBuilder, "Version: %s\n", okVersion)
	p.preCheckString(contentBuilder, "Release: %s\n", preRelease)
	p.preCheckString(contentBuilder, "Group: %s\n", p.Group)
	p.preCheckString(contentBuilder, "License: %s\n", p.License)
	p.preCheckString(contentBuilder, "Url: %s\n", p.URL)
	p.preCheckString(contentBuilder, "Summary: %s\n", p.Summary)
	p.preCheckString(contentBuilder, "AutoReqProv: %s\n", p.AutoReqProv)
	p.preCheckString(contentBuilder, "\nBuildRequires:%s\n", strings.Join(p.BuildRequires, ", "))
	p.preCheckString(contentBuilder, "\nRequires:%s\n", strings.Join(p.Requires, ", "))
	p.preCheckString(contentBuilder, "\nProvides:%s\n", strings.Join(p.Provides, ", "))
	p.preCheckString(contentBuilder, "\nConflicts:%s\n", strings.Join(p.Conflicts, ", "))
	p.preCheckString(contentBuilder, "\n%%description\n%s\n", p.Description)

	contentBuilder.WriteString(fmt.Sprintf("\n%%prep\n"))
	contentBuilder.WriteString(fmt.Sprintf("\n%%build\n"))
	contentBuilder.WriteString(fmt.Sprintf("\n%%install\n"))

	install, err := p.generateInstallSection(sourceDir)
	if err != nil {
		return "", errors.WithStack(err)
	}

	return contentBuilder.String(), nil
}

func (p *Package) GenerateSpecFile(sourceDir string) (string, error) {
	okVersion, preRelease, err := generateVersion(p)
	if err != nil {
		return "", err
	}

	spec, err := p.generateSpecContent(okVersion, preRelease, sourceDir)
	if err != nil {
		return "", err
	}

	return spec, nil
}

func (p *Package) WriteEnvFile() (string, error) {
	file := ""

	tempDir, err := os.MkdirTemp("", "rpm-envs")
	if err != nil {
		return file, errors.WithStack(err)
	}

	file = filepath.Join(tempDir, p.Name+".sh")

	content := p.generateEnvContent()

	err = errors.WithStack(os.WriteFile(file, []byte(content), 0644))
	if err != nil {
		return file, err
	}

	return file, nil
}

func (p *Package) processPaths(allDirs *[]string, allFiles *[]string, items []string, from string, to string, base string) {
	for _, item := range items {
		n := item
		if len(item) >= len(base) && item[0:len(base)] == base {
			n = item[len(base):]
		}
		n = filepath.Join("%{buildroot}", to, n)
		dir := fmt.Sprintf("mkdir -p %s\n", filepath.Dir(n))
		if !utils.Contains(*allDirs, dir) {
			*allDirs = append(*allDirs, dir)
		}

		if stat, err := os.Stat(item); err == nil && !stat.IsDir() {
			file := fmt.Sprintf("cp %s %s\n", item, filepath.Dir(n))
			if !utils.Contains(*allFiles, file) {
				*allFiles = append(*allFiles, file)
			}
		}
	}
}

// generateInstallSection generates the content of the %install section
func (p *Package) generateInstallSection(sourceDir string) (string, error) {
	allDirs := make([]string, 0)
	allFiles := make([]string, 0)

	absSourceDir, err := filepath.Abs(sourceDir)
	if err != nil {
		return "", errors.WithStack(err)
	}

	for i, fileInst := range p.Files {
		if fileInst.From == "" {
			log.Printf("Skipped pkg.Files[%d] %q", i, fileInst)
			continue
		}

		from := utils.EnsureAbsolute(fileInst.From, absSourceDir)
		base := utils.EnsureAbsolute(fileInst.Base, absSourceDir)

		log.Printf("fileInst.From=%q\n", from)
		log.Printf("fileInst.To=%q\n", fileInst.To)
		log.Printf("fileInst.Base=%q\n", base)

		items, err := zglob.Glob(from)
		if err != nil {
			log.Printf("Files not found in '%s'\n", from)
			continue
		}

		log.Printf("items=%q\n", items)

		p.processPaths(&allDirs, &allFiles, items, from, fileInst.To, base)
	}

	var contentBuilder strings.Builder

	for _, d := range allDirs {
		contentBuilder.WriteString(d)
	}

	for _, f := range allFiles {
		contentBuilder.WriteString(f)
	}

	content := contentBuilder.String()

	log.Printf("content=\n%s\n", content)

	return content, nil
}

func (p *Package) generateFilesSection(sourceDir string) (string, error) {
	sourceDir, err := filepath.Abs(sourceDir)
	if err != nil {
		return "", errors.WithStack(err)
	}

	allItems, err := p.processPackageFiles(sourceDir)
	if err != nil {
		return "", err
	}

	return createContent(allItems), nil
}

func (p *Package) processPackageFiles(sourceDir string) ([]fileItem, error) {
	allItems := make([]fileItem, 0)
	var err error

	for _, fileInst := range p.Files {
		items, err := matchItems(sourceDir, fileInst)
		if err != nil {
			return nil, err
		}

		collectedItems := collectFileItems(items, fileInst)
		allItems = append(allItems, collectedItems...)
	}

	return allItems, nil
}

func matchItems(sourceDir string, fileInst *FileInstance) ([]string, error) {
	from, base := adjustPaths(sourceDir, fileInst.From, fileInst.Base)

	logFileInstDetails(from, base, fileInst.To, fileInst.Type)

	items, err := zglob.Glob(from)
	if err != nil {
		log.Printf("Files not found in '%s'\n", from)
	}

	return items, err
}

func collectFileItems(items []string, fileInst *FileInstance) []fileItem {
	collectedItems := make([]fileItem, 0)
	for _, item := range items {
		fileItem := createFileItem(item, fileInst)
		collectedItems = append(collectedItems, fileItem)
	}

	return collectedItems
}

func createFileItem(item string, fileInst *FileInstance) fileItem {
	n := adjustItemPath(item, fileInst.Base, fileInst.To)
	itemType := " "
	if fileInst.Type != "" {
		itemType += fileInst.Type
	}

	return fileItem{n, itemType}
}

func adjustPaths(sourceDir, from, base string) (string, string) {
	if !filepath.IsAbs(from) {
		from = filepath.Join(sourceDir, from)
	}

	if !filepath.IsAbs(base) {
		base = filepath.Join(sourceDir, base)
	}

	return from, base
}

func adjustItemPath(item, base, to string) string {
	if len(item) >= len(base) && item[0:len(base)] == base {
		item = item[len(base):]
	}
	return filepath.Join(to, item)
}

func logFileInstDetails(from, base, to, itemType string) {
	log.Printf("fileInst.From=%q\n", from)
	log.Printf("fileInst.To=%q\n", to)
	log.Printf("fileInst.Base=%q\n", base)
	log.Printf("fileInst.Type=%q\n", itemType)
}

func createContent(allItems []fileItem) string {
	var content strings.Builder
	for _, item := range allItems {
		content.WriteString(fmt.Sprintf("%s%s\n", item.Type, item.Path))
	}
	log.Printf("content=\n%s\n", content.String())
	return content.String()
}

func (p *Package) getChangelogContent() (string, error) {
	if p.ChangelogFile != "" {
		return p.readChangelogFile(p.ChangelogFile)
	} else if p.ChangelogCmd != "" {
		return p.executeChangelogCmd(p.ChangelogCmd)
	}
	return "", errors.New("Neither ChangelogFile nor ChangelogCmd provided in the Package")
}

func (p *Package) readChangelogFile(filepath string) (string, error) {
	c, err := os.ReadFile(filepath)
	if err != nil {
		return "", errors.WithStack(err)
	}
	return string(c), nil
}

func (p *Package) executeChangelogCmd(cmdStr string) (string, error) {
	wd, err := os.Getwd()
	if err != nil {
		return "", errors.WithStack(err)
	}

	cmd, err := utils.Command(wd, cmdStr)
	if err != nil {
		return "", errors.WithStack(err)
	}

	cmd.Stdout = nil
	c, err := cmd.Output()
	if err != nil {
		return "", errors.WithStack(err)
	}

	return string(c), nil
}

func (p *Package) createEntry(key, value string) *Entry {
	return &Entry{Key: key, Value: value}
}

func (p *Package) writeEntry(e *Entry) string {
	return fmt.Sprintf("%s=%s\n", e.Key, e.Value)
}

func (p *Package) writeBooleanEntry(key string, value bool) string {
	val := "false"
	if value {
		val = "true"
	}
	return p.writeEntry(p.createEntry(key, val))
}

func (p *Package) writeOptionalEntry(key, value string) string {
	if value != "" {
		return p.writeEntry(p.createEntry(key, value))
	}
	return ""
}

func (p *Package) generateEnvContent() string {
	content := "#!/bin/bash\n\n"

	for k, v := range p.Envs {
		content += fmt.Sprintf("%s=%s\n", k, v)
	}
	content += fmt.Sprint("\n")
	for k := range p.Envs {
		content += fmt.Sprintf("export %s\n", k)
	}

	return content
}
